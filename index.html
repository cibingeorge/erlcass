<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>ErlCass by silviucpp</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>ErlCass</h1>
        <p>An Erlang Cassandra driver, based on Datastax cpp driver focused on performance.</p>

        <p class="view"><a href="https://github.com/silviucpp/erlcass">View the Project on GitHub <small>silviucpp/erlcass</small></a></p>


        <ul>
          <li><a href="https://github.com/silviucpp/erlcass/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/silviucpp/erlcass/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/silviucpp/erlcass">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="erlcass" class="anchor" href="#erlcass" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ErlCass</h1>

<p><em>An Erlang Cassandra driver, based on <a href="https://github.com/datastax/cpp-driver">DataStax cpp driver</a> focused on performance.</em></p>

<h3>
<a id="implementation-note" class="anchor" href="#implementation-note" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Implementation note</h3>

<h4>
<a id="how-erlcass-affects-the-erlang-schedulers" class="anchor" href="#how-erlcass-affects-the-erlang-schedulers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How ErlCass affects the Erlang schedulers</h4>

<p>It's well known that NIF's can affect the Erlang schedulers performances in case the functions are not returning in less than 1-2 ms and blocks the threads. </p>

<p>Because the DataStax cpp driver is async, <code>ErlCass</code> won't block the scheduler threads and all calls to the native functions will return immediately.
The DataStax driver use it's own threads for managing the requests. Also the responses are received on this threads and sent back to Erlang calling process using <code>enif_send</code> in a async manner. </p>

<h4>
<a id="changelog" class="anchor" href="#changelog" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Changelog</h4>

<p>Changelog is available <a href="https://github.com/silviucpp/erlcass/blob/master/CHANGELOG.md">here</a>.</p>

<h3>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting started:</h3>

<p>The application is compatible with both <code>rebar</code> or <code>rebar3</code>.</p>

<p>In case you receive any error related to compiling of the DataStax driver you can try to run <code>rebar</code> with <code>sudo</code> in order 
to install all dependencies. Also you can check <a href="https://github.com/silviucpp/erlcass/wiki/Getting-started">wiki section</a> for more details</p>

<h3>
<a id="data-types" class="anchor" href="#data-types" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data types</h3>

<p>In order to see the relation between Cassandra column types and Erlang types please check this <a href="https://github.com/silviucpp/erlcass/wiki/Data-types">wiki section</a></p>

<h3>
<a id="starting-the-application" class="anchor" href="#starting-the-application" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Starting the application</h3>

<div class="highlight highlight-source-erlang"><pre><span class="pl-en">application</span>:<span class="pl-en">start</span>(<span class="pl-c1">erlcass</span>).</pre></div>

<h3>
<a id="enable-logs-and-setting-custom-log-handler" class="anchor" href="#enable-logs-and-setting-custom-log-handler" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Enable logs and setting custom log handler</h3>

<p>Available Log levels are:</p>

<div class="highlight highlight-source-erlang"><pre>-<span class="pl-k">define</span>(<span class="pl-en">CASS_LOG_DISABLED</span>, <span class="pl-c1">0</span>).
-<span class="pl-k">define</span>(<span class="pl-en">CASS_LOG_CRITICAL</span>, <span class="pl-c1">1</span>).
-<span class="pl-k">define</span>(<span class="pl-en">CASS_LOG_ERROR</span>, <span class="pl-c1">2</span>).
-<span class="pl-k">define</span>(<span class="pl-en">CASS_LOG_WARN</span>, <span class="pl-c1">3</span>). (<span class="pl-c1">default</span>)
-<span class="pl-k">define</span>(<span class="pl-en">CASS_LOG_INFO</span>, <span class="pl-c1">4</span>).
-<span class="pl-k">define</span>(<span class="pl-en">CASS_LOG_DEBUG</span>,<span class="pl-c1">5</span>).
-<span class="pl-k">define</span>(<span class="pl-en">CASS_LOG_TRACE</span>, <span class="pl-c1">6</span>).</pre></div>

<p>In order to change the log level for the native driver you need to set the <code>log_level</code> environment variable for ErlCass into your config file.
By default the logs are printed to console. In order to print them into an external log system you can use the <code>set_log_function</code> method.
The callback should be a function with arity 1 which will receive a record of <code>log_msg</code> type defined as</p>

<p><code>
-record(log_msg, {ts, severity, severity_str, file, line, function, message}).
</code></p>

<p>where</p>

<ul>
<li>
<code>ts</code> is The millisecond timestamp (since the Epoch) when the message was logged (int)</li>
<li>
<code>severity</code> The severity of the log message (int value from 1 to 6)</li>
<li>
<code>severity_str</code> The severity of the log message as a string value (binary string)</li>
<li>
<code>file</code> The file where the message was logged (binary string)</li>
<li>
<code>line</code> The line in the file where the message was logged (int)</li>
<li>
<code>function</code> The function where the message was logged (binary string)</li>
<li>
<code>message</code> The message (binary string)</li>
</ul>

<p>or under <code>{_Severity, Msg, Args}</code> format (for all messages generated from Erlang code)</p>

<h3>
<a id="setting-the-cluster-options" class="anchor" href="#setting-the-cluster-options" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Setting the cluster options</h3>

<p>The cluster options can be set at runtime using <code>erlcass:set_cluster_options/1</code> method as follow:</p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-c1">ok</span> <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">set_cluster_options</span>([
    {<span class="pl-c1">contact_points</span>, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>172.17.3.129,172.17.3.130,172.17.3.131<span class="pl-pds">"</span></span>&gt;&gt;},
    {<span class="pl-c1">port</span>, <span class="pl-c1">9042</span>},
    ...
]).</pre></div>

<p>or inside your <code>app.config</code> file:</p>

<div class="highlight highlight-source-erlang"><pre>{<span class="pl-c1">erlcass</span>, [
    {<span class="pl-c1">log_level</span>, <span class="pl-c1">3</span>},
    {<span class="pl-c1">keyspace</span>, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>keyspace<span class="pl-pds">"</span></span>&gt;&gt;},
    {<span class="pl-c1">cluster_options</span>,[
        {<span class="pl-c1">contact_points</span>, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>172.17.3.129,172.17.3.130,172.17.3.131<span class="pl-pds">"</span></span>&gt;&gt;},
        {<span class="pl-c1">port</span>, <span class="pl-c1">9042</span>},
        {<span class="pl-c1">load_balance_dc_aware</span>, {&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>dc-name<span class="pl-pds">"</span></span>&gt;&gt;, <span class="pl-c1">0</span>, <span class="pl-c1">false</span>}},
        {<span class="pl-c1">latency_aware_routing</span>, <span class="pl-c1">true</span>},
        {<span class="pl-c1">token_aware_routing</span>, <span class="pl-c1">true</span>},
        {<span class="pl-c1">number_threads_io</span>, <span class="pl-c1">4</span>},
        {<span class="pl-c1">queue_size_io</span>, <span class="pl-c1">128000</span>},
        {<span class="pl-c1">max_connections_host</span>, <span class="pl-c1">5</span>},
        {<span class="pl-c1">pending_requests_high_watermark</span>, <span class="pl-c1">128000</span>},
        {<span class="pl-c1">tcp_nodelay</span>, <span class="pl-c1">true</span>},
        {<span class="pl-c1">tcp_keepalive</span>, {<span class="pl-c1">true</span>, <span class="pl-c1">1800</span>}},
        {<span class="pl-c1">default_consistency_level</span>, <span class="pl-c1">6</span>}
    ]}
]},</pre></div>

<p>Tips for production environment:</p>

<ul>
<li>Use <code>token_aware_routing</code> and <code>latency_aware_routing</code>
</li>
<li>Don't use <code>number_threads_io</code> bigger than the number of your cores.</li>
<li>Use <code>tcp_nodelay</code> and also enable <code>tcp_keepalive</code> </li>
</ul>

<p>All available options are described in the following <a href="https://github.com/silviucpp/erlcass/wiki/Available-cluster-options">wiki section</a>.</p>

<h3>
<a id="creating-a-session" class="anchor" href="#creating-a-session" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Creating a session</h3>

<p><em>Currently this is limited to one session per application. This is a DataStax recommendations as well</em></p>

<p>In order to connect the session to a keyspace as well use as option:</p>

<div class="highlight highlight-source-erlang"><pre> [{<span class="pl-c1">keyspace</span>, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>keyspace_name_here<span class="pl-pds">"</span></span>&gt;&gt;}].</pre></div>

<p>In case you don't want to connect the session to any keyspace use as argument an empty list.</p>

<p>Example:</p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-c1">ok</span> <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">create_session</span>([{<span class="pl-c1">keyspace</span>, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>stresscql<span class="pl-pds">"</span></span>&gt;&gt;}]).</pre></div>

<h3>
<a id="add-a-prepare-statement" class="anchor" href="#add-a-prepare-statement" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Add a prepare statement</h3>

<p>Example:</p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-c1">ok</span> <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">add_prepare_statement</span>(<span class="pl-c1">select_blogpost</span>,
                                   &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>select * from blogposts where domain = ? LIMIT 1<span class="pl-pds">"</span></span>&gt;&gt;),</pre></div>

<p>In case you want to overwrite the default consistency level for that prepare statement use a tuple for the query argument: <code>{Query, ConsistencyLevelHere}</code></p>

<p>Also this is possible using <code>{Query, Options}</code> where options is a proplist with the following options supported:</p>

<ul>
<li>
<code>consistency_level</code> - If it's missing the statement will be executed using the default consistency level value.</li>
<li>
<code>serial_consistency_level</code> - That consistency can only be either <code>?CASS_CONSISTENCY_SERIAL</code> or <code>?CASS_CONSISTENCY_LOCAL_SERIAL</code> and if not present, it defaults to <code>?CASS_CONSISTENCY_SERIAL</code>. This option will be ignored for anything else that a conditional update/insert.</li>
</ul>

<p>Example:</p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-c1">ok</span> <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">add_prepare_statement</span>(
                <span class="pl-c1">select_blogpost</span>,
                { &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>select * from blogposts where domain = ? LIMIT 1<span class="pl-pds">"</span></span>&gt;&gt;, <span class="pl-k">?</span><span class="pl-en">CASS_CONSISTENCY_LOCAL_QUORUM</span> }).</pre></div>

<p>or </p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-c1">ok</span> <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">add_prepare_statement</span>(
                <span class="pl-c1">insert_blogpost</span>,
                {&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>UPDATE blogposts SET author = ? WHERE domain = ? IF EXISTS<span class="pl-pds">"</span></span>&gt;&gt;, [
                    {<span class="pl-c1">consistency_level</span>, <span class="pl-k">?</span><span class="pl-en">CASS_CONSISTENCY_LOCAL_QUORUM</span>},
                    {<span class="pl-c1">serial_consistency_level</span>, <span class="pl-k">?</span><span class="pl-en">CASS_CONSISTENCY_LOCAL_SERIAL</span>}
                ]}).</pre></div>

<h3>
<a id="run-a-prepared-statement-query" class="anchor" href="#run-a-prepared-statement-query" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Run a prepared statement query</h3>

<p>In case the first parameter for <code>erlcass:execute</code> is an atom then the driver will try to find the associated prepared statement and to run it.
You can bind the parameters in 2 ways: by name and by index. You can use <code>?BIND_BY_INDEX</code> and <code>?BIND_BY_NAME</code> from execute/3 in order to specify the desired method. By default is binding by index</p>

<p>Example:</p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-c">%bind by name</span>
<span class="pl-en">erlcass</span>:<span class="pl-en">execute</span>(<span class="pl-c1">select_blogpost</span>, <span class="pl-k">?</span><span class="pl-en">BIND_BY_NAME</span>, [{&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>domain<span class="pl-pds">"</span></span>&gt;&gt;, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Domain_1<span class="pl-pds">"</span></span>&gt;&gt;}]).
<span class="pl-c">%bind by index</span>
<span class="pl-en">erlcass</span>:<span class="pl-en">execute</span>(<span class="pl-c1">select_blogpost</span>, [&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Domain_1<span class="pl-pds">"</span></span>&gt;&gt;]).
<span class="pl-c">%bind by index</span>
<span class="pl-en">erlcass</span>:<span class="pl-en">execute</span>(<span class="pl-c1">select_blogpost</span>, <span class="pl-k">?</span><span class="pl-en">BIND_BY_INDEX</span>, [&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Domain_1<span class="pl-pds">"</span></span>&gt;&gt;]).</pre></div>

<p>In case of maps you can use <code>key(field)</code> and <code>value(field)</code> in order to bind by name.</p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-c">%table: CREATE TABLE test_map(key int PRIMARY KEY, value map&lt;text,text&gt;)</span>
<span class="pl-c">%statement: UPDATE examples.test_map SET value[?] = ? WHERE key = ?</span>
<span class="pl-c">%bind by index</span>
<span class="pl-en">erlcass</span>:<span class="pl-en">execute</span>(<span class="pl-c1">identifier</span>, [&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>collection_key_here<span class="pl-pds">"</span></span>&gt;&gt;, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>collection_value_here<span class="pl-pds">"</span></span>&gt;&gt;, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>key_here<span class="pl-pds">"</span></span>&gt;&gt;]).
<span class="pl-c">%bind by name</span>
<span class="pl-en">erlcass</span>:<span class="pl-en">execute</span>(<span class="pl-c1">insert_test_bind</span>, <span class="pl-k">?</span><span class="pl-en">BIND_BY_NAME</span>, [{&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>key(value)<span class="pl-pds">"</span></span>&gt;&gt;, <span class="pl-smi">CollectionIndex1</span>}, {&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>value(value)<span class="pl-pds">"</span></span>&gt;&gt;, <span class="pl-smi">CollectionValue1</span>}, {&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>key<span class="pl-pds">"</span></span>&gt;&gt;, <span class="pl-smi">Key1</span>}]),</pre></div>

<h3>
<a id="async-queries-and-blocking-queries" class="anchor" href="#async-queries-and-blocking-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Async queries and blocking queries</h3>

<p>For blocking operations use <code>erlcass:execute</code>, for async execution use : <code>erlcass:async_execute</code>.
The blocking operation will block the current erlang process (still async into the native code in order to avoid freezing of the VM threads) until will get the result from the cluster.</p>

<p>In case of an async execution the calling process will receive a message of the following form: <code>{execute_statement_result, Tag, Result}</code></p>

<p>For example:</p>

<div class="highlight highlight-source-erlang"><pre>{<span class="pl-c1">ok</span>, <span class="pl-smi">Tag</span>} <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">async_execute</span>(...),
    <span class="pl-k">receive</span>
        {<span class="pl-c1">execute_statement_result</span>, <span class="pl-smi">Tag</span>, <span class="pl-smi">Result</span>} -&gt;
            <span class="pl-smi">Result</span>
    <span class="pl-k">end</span>.</pre></div>

<h3>
<a id="non-prepared-statements-queries" class="anchor" href="#non-prepared-statements-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Non prepared statements queries</h3>

<p>The only downside is that you have to provide metadata about the types of the fields that are bound.
The data types can be found into <code>erlcass.hrl</code> file as follow:</p>

<div class="highlight highlight-source-erlang"><pre>-<span class="pl-k">define</span>(<span class="pl-en">CASS_TEXT</span>, <span class="pl-c1">text</span>).                         <span class="pl-c">%use for (ascii, text, varchar)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_TINYINT</span>, <span class="pl-c1">tinyint</span>).                   <span class="pl-c">%use for (tinyint)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_SMALLINT</span>, <span class="pl-c1">smallint</span>).                 <span class="pl-c">%use for (smallint)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_INT</span>, <span class="pl-c1">int</span>).                           <span class="pl-c">%use for (int)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_DATE</span>, <span class="pl-c1">date</span>).                         <span class="pl-c">%use for (date)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_BIGINT</span>, <span class="pl-c1">bigint</span>).                     <span class="pl-c">%use for (timestamp, counter, bigint, time)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_BLOB</span>, <span class="pl-c1">blob</span>).                         <span class="pl-c">%use for (varint, blob)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_BOOLEAN</span>, <span class="pl-c1">bool</span>).                      <span class="pl-c">%use for (bool)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_FLOAT</span>, <span class="pl-c1">float</span>).                       <span class="pl-c">%use for (float)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_DOUBLE</span>, <span class="pl-c1">double</span>).                     <span class="pl-c">%use for (double)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_INET</span>, <span class="pl-c1">inet</span>).                         <span class="pl-c">%use for (inet)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_UUID</span>, <span class="pl-c1">uuid</span>).                         <span class="pl-c">%use for (timeuuid, uuid)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_DECIMAL</span>, <span class="pl-c1">decimal</span>).                   <span class="pl-c">%use for (decimal)</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_LIST</span>(<span class="pl-smi">ValueType</span>), {<span class="pl-c1">list</span>, <span class="pl-smi">ValueType</span>}). <span class="pl-c">%use for list</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_SET</span>(<span class="pl-smi">ValueType</span>), {<span class="pl-c1">set</span>, <span class="pl-smi">ValueType</span>}).   <span class="pl-c">%use for set</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_MAP</span>(<span class="pl-smi">KeyType</span>, <span class="pl-smi">ValueType</span>), {<span class="pl-c1">map</span>, <span class="pl-smi">KeyType</span>, <span class="pl-smi">ValueType</span>}). <span class="pl-c">%use for map</span>
-<span class="pl-k">define</span>(<span class="pl-en">CASS_TUPLE</span>(<span class="pl-smi">Types</span>), {<span class="pl-c1">tuple</span>, <span class="pl-smi">Types</span>}).       <span class="pl-c">%use for tuples</span></pre></div>

<p>The same rules apply for setting the desired consistency level as on prepared statements (see Add prepare statement section).
Example with binding by index (requires metadata parsing all the time so it might not be the best solution when using non prepared statements):</p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-en">erlcass</span>:<span class="pl-en">execute</span>(&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>select * from blogposts where domain = ? LIMIT 1<span class="pl-pds">"</span></span>&gt;&gt;,
                [{<span class="pl-k">?</span><span class="pl-en">CASS_TEXT</span>, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Domain_1<span class="pl-pds">"</span></span>&gt;&gt;}]).</pre></div>

<p>or:</p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-en">erlcass</span>:<span class="pl-en">execute</span>(&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>select * from blogposts where domain = 'Domain_1' LIMIT 1<span class="pl-pds">"</span></span>&gt;&gt;).</pre></div>

<h3>
<a id="batched-queries" class="anchor" href="#batched-queries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Batched queries</h3>

<p>In order to perform batched statements you can use <code>erlcass:batch_async_execute/3</code> or <code>erlcass:batch_execute/3</code>.</p>

<p>First argument is the batch type and is defined as:</p>

<div class="highlight highlight-source-erlang"><pre>-<span class="pl-k">define</span>(<span class="pl-en">CASS_BATCH_TYPE_LOGGED</span>, <span class="pl-c1">0</span>).
-<span class="pl-k">define</span>(<span class="pl-en">CASS_BATCH_TYPE_UNLOGGED</span>, <span class="pl-c1">1</span>).
-<span class="pl-k">define</span>(<span class="pl-en">CASS_BATCH_TYPE_COUNTER</span>, <span class="pl-c1">2</span>).</pre></div>

<p>The second one is a list of statements (prepared or normal statements) that needs to be executed in the batch.</p>

<p>The third argument is a list of options in <code>{Key, Value}</code> format (proplist):</p>

<ul>
<li>
<code>consistency_level</code> - If it's missing the batch will be executed using the default consistency level value.</li>
<li>
<code>serial_consistency_level</code> - That consistency can only be either <code>?CASS_CONSISTENCY_SERIAL</code> or <code>?CASS_CONSISTENCY_LOCAL_SERIAL</code> and if not present, it defaults to <code>?CASS_CONSISTENCY_SERIAL</code>. This option will be ignored for anything else that a conditional update/insert.</li>
</ul>

<p>Example:</p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-smi">InsertStatement</span> <span class="pl-k">=</span> &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>INSERT INTO erlang_driver_test.entries1(id, age, email) VALUES (?, ?, ?)<span class="pl-pds">"</span></span>&gt;&gt;,
<span class="pl-c1">ok</span> <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">add_prepare_statement</span>(<span class="pl-c1">insert_prep</span>, <span class="pl-smi">InsertStatement</span>),
{<span class="pl-c1">ok</span>, <span class="pl-smi">Stm1</span>} <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">create_statement</span>(<span class="pl-smi">InsertStatement</span>, [{<span class="pl-k">?</span><span class="pl-en">CASS_TEXT</span>, <span class="pl-smi">Id1</span>}, {<span class="pl-k">?</span><span class="pl-en">CASS_INT</span>, <span class="pl-smi">Age1</span>}, {<span class="pl-k">?</span><span class="pl-en">CASS_TEXT</span>, <span class="pl-smi">Email1</span>}]),
{<span class="pl-c1">ok</span>, <span class="pl-smi">Stm2</span>} <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">bind_prepared_statement</span>(<span class="pl-c1">insert_prep</span>),
<span class="pl-c1">ok</span> <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">bind_prepared_params_by_name</span>(<span class="pl-smi">Stm2</span>, [{&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>&gt;&gt;, <span class="pl-smi">Id2</span>}, {&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>age<span class="pl-pds">"</span></span>&gt;&gt;, <span class="pl-smi">Age2</span>}, {&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>email<span class="pl-pds">"</span></span>&gt;&gt;, <span class="pl-smi">Email2</span>}]),
{<span class="pl-c1">ok</span>, []} <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">batch_execute</span>(<span class="pl-k">?</span><span class="pl-en">CASS_BATCH_TYPE_LOGGED</span>, [<span class="pl-smi">Stm1</span>, <span class="pl-smi">Stm2</span>], [{<span class="pl-c1">consistency_level</span>, <span class="pl-k">?</span><span class="pl-en">CASS_CONSISTENCY_QUORUM</span>}]).</pre></div>

<h3>
<a id="working-with-uuid-or-timeuuid-fields" class="anchor" href="#working-with-uuid-or-timeuuid-fields" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Working with uuid or timeuuid fields:</h3>

<ul>
<li>
<code>erlcass_uuid:gen_time()</code>   -&gt; Generates a V1 (time) UUID</li>
<li>
<code>erlcass_uuid:gen_random()</code> -&gt; Generates a new V4 (random) UUID</li>
<li>
<code>erlcass_uuid:gen_from_ts(Ts)</code> -&gt; Generates a V1 (time) UUID for the specified timestamp</li>
<li>
<code>erlcass_uuid:min_from_ts(Ts)</code> -&gt; Sets the UUID to the minimum V1 (time) value for the specified timestamp,</li>
<li>
<code>erlcass_uuid:max_from_ts(Ts)</code> -&gt; Sets the UUID to the maximum V1 (time) value for the specified timestamp,</li>
<li>
<code>erlcass_uuid:get_ts(Uuid)</code> -&gt; Gets the timestamp for a V1 UUID,</li>
<li>
<code>erlcass_uuid:get_version(Uuid)</code> -&gt; Gets the version for a UUID (V1 or V4)</li>
</ul>

<h3>
<a id="working-with-date-time-fields" class="anchor" href="#working-with-date-time-fields" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Working with date, time fields:</h3>

<ul>
<li>
<code>erlcass_time:date_from_epoch(EpochSecs)</code> -&gt; Converts a unix timestamp (in seconds) to the Cassandra <code>date</code> type. The <code>date</code> type represents the number of days since the Epoch (1970-01-01) with the Epoch centered at the value 2^31.</li>
<li>
<code>erlcass_time:time_from_epoch(EpochSecs)</code> -&gt; Converts a unix timestamp (in seconds) to the Cassandra <code>time</code> type. The <code>time</code> type represents the number of nanoseconds since midnight (range 0 to 86399999999999).</li>
<li>
<code>erlcass_time:date_time_to_epoch(Date, Time)</code> -&gt; Combines the Cassandra <code>date</code> and <code>time</code> types to Epoch time in seconds. Returns Epoch time in seconds. Negative times are possible if the date occurs before the Epoch (1970-1-1).</li>
</ul>

<h3>
<a id="getting-metrics" class="anchor" href="#getting-metrics" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting metrics</h3>

<p>In order to get metrics from the native driver you can use <code>erlcass:get_metrics().</code></p>

<h5>
<a id="requests" class="anchor" href="#requests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>requests</h5>

<ul>
<li>
<code>min</code> - Minimum in microseconds</li>
<li>
<code>max</code> - Maximum in microseconds</li>
<li>
<code>mean</code> - Mean in microseconds</li>
<li>
<code>stddev</code> - Standard deviation in microseconds</li>
<li>
<code>median</code> - Median in microseconds</li>
<li>
<code>percentile_75th</code> - 75th percentile in microseconds</li>
<li>
<code>percentile_95th</code> - 95th percentile in microseconds</li>
<li>
<code>percentile_98th</code> - 98th percentile in microseconds</li>
<li>
<code>percentile_99th</code> - 99the percentile in microseconds</li>
<li>
<code>percentile_999th</code> - 99.9th percentile in microseconds</li>
<li>
<code>mean_rate</code> - Mean rate in requests per second</li>
<li>
<code>one_minute_rate</code> - 1 minute rate in requests per second</li>
<li>
<code>five_minute_rate</code> - 5 minute rate in requests per second</li>
<li>
<code>fifteen_minute_rate</code> - 15 minute rate in requests per second</li>
</ul>

<h5>
<a id="stats" class="anchor" href="#stats" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>stats</h5>

<ul>
<li>
<code>total_connections</code> - The total number of connections</li>
<li>
<code>available_connections</code> - The number of connections available to take requests</li>
<li>
<code>exceeded_pending_requests_water_mark</code> - Occurrences when requests exceeded a pool's water mark</li>
<li>
<code>exceeded_write_bytes_water_mark</code> - Occurrences when number of bytes exceeded a connection's water mark</li>
</ul>

<h5>
<a id="errors" class="anchor" href="#errors" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>errors</h5>

<ul>
<li>
<code>connection_timeouts</code> - Occurrences of a connection timeout</li>
<li>
<code>pending_request_timeouts</code> - Occurrences of requests that timed out waiting for a connection</li>
<li>
<code>request_timeouts</code> - Occurrences of requests that timed out waiting for a request to finish</li>
</ul>

<h3>
<a id="low-level-methods" class="anchor" href="#low-level-methods" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Low level methods</h3>

<p>Each query requires an internal statement (prepared or not). You can reuse the same statement object for multiple queries
performed in the same process.</p>

<h5>
<a id="getting-a-statement-reference-for-a-prepared-statement-query" class="anchor" href="#getting-a-statement-reference-for-a-prepared-statement-query" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting a statement reference for a prepared statement query</h5>

<div class="highlight highlight-source-erlang"><pre>{<span class="pl-c1">ok</span>, <span class="pl-smi">Statement</span>} <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">bind_prepared_statement</span>(<span class="pl-c1">select_blogpost</span>).</pre></div>

<h5>
<a id="getting-a-statement-reference-for-a-non-prepared-query" class="anchor" href="#getting-a-statement-reference-for-a-non-prepared-query" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting a statement reference for a non prepared query</h5>

<div class="highlight highlight-source-erlang"><pre>{<span class="pl-c1">ok</span>, <span class="pl-smi">Statement</span>} <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">create_statement</span>(&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>select * from blogposts where domain = ? LIMIT 1<span class="pl-pds">"</span></span>&gt;&gt;,
                                           [{<span class="pl-k">?</span><span class="pl-en">CASS_TEXT</span>, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Domain_1<span class="pl-pds">"</span></span>&gt;&gt;}]).</pre></div>

<h5>
<a id="bind-the-values-for-a-prepared-statement-before-executing" class="anchor" href="#bind-the-values-for-a-prepared-statement-before-executing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Bind the values for a prepared statement before executing</h5>

<div class="highlight highlight-source-erlang"><pre><span class="pl-c">%bind by name</span>
<span class="pl-c1">ok</span> <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">bind_prepared_params_by_name</span>(<span class="pl-c1">select_blogpost</span>, [{&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>domain<span class="pl-pds">"</span></span>&gt;&gt;, &lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Domain_1<span class="pl-pds">"</span></span>&gt;&gt;}]);
<span class="pl-c">%bind by index</span>
<span class="pl-c1">ok</span> <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">bind_prepared_params_by_index</span>(<span class="pl-c1">select_blogpost</span>, [&lt;&lt;<span class="pl-s"><span class="pl-pds">"</span>Domain_1<span class="pl-pds">"</span></span>&gt;&gt;]);</pre></div>

<p>For mode details about bind by index and name please see: 'Run a prepared statement query' section</p>

<h5>
<a id="execute-a-statement-async" class="anchor" href="#execute-a-statement-async" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Execute a statement async</h5>

<div class="highlight highlight-source-erlang"><pre>{<span class="pl-c1">ok</span>, <span class="pl-smi">Tag</span>} <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">async_execute_statement</span>(<span class="pl-smi">Statement</span>).</pre></div>

<h5>
<a id="execute-a-statement-in-blocking-mode" class="anchor" href="#execute-a-statement-in-blocking-mode" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Execute a statement in blocking mode</h5>

<div class="highlight highlight-source-erlang"><pre><span class="pl-smi">Result</span> <span class="pl-k">=</span> <span class="pl-en">erlcass</span>:<span class="pl-en">execute_statement</span>(<span class="pl-smi">Statement</span>).</pre></div>

<p>Using this low level functions are very useful when you want to run in loop a certain query. Helps you to avoid recreating the statements all the time.
For example here is how the execute method is implemented:</p>

<div class="highlight highlight-source-erlang"><pre><span class="pl-en">execute</span>(<span class="pl-smi">Identifier</span>, <span class="pl-smi">Params</span>) <span class="pl-k">-&gt;</span>
    <span class="pl-k">if</span>
        <span class="pl-en">is_atom</span>(<span class="pl-smi">Identifier</span>) -&gt;
            {<span class="pl-c1">ok</span>, <span class="pl-smi">Statement</span>} <span class="pl-k">=</span> <span class="pl-en">bind_prepared_statement</span>(<span class="pl-smi">Identifier</span>),
            <span class="pl-c1">ok</span> <span class="pl-k">=</span> <span class="pl-en">bind_prepared_params</span>(<span class="pl-smi">Statement</span>, <span class="pl-smi">Params</span>);
        <span class="pl-c1">true</span> -&gt;
            {<span class="pl-c1">ok</span>, <span class="pl-smi">Statement</span>} <span class="pl-k">=</span> <span class="pl-en">create_statement</span>(<span class="pl-smi">Identifier</span>, <span class="pl-smi">Params</span>)
    <span class="pl-k">end</span>,
    <span class="pl-en">execute_statement</span>(<span class="pl-smi">Statement</span>).</pre></div>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/silviucpp">silviucpp</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
